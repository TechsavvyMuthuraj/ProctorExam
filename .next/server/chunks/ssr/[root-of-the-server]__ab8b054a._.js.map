{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 223, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/genkit.ts"],"sourcesContent":["import {genkit} from 'genkit';\nimport {googleAI} from '@genkit-ai/googleai';\n\nexport const ai = genkit({\n  plugins: [googleAI()],\n  model: 'googleai/gemini-2.5-flash',\n});\n"],"names":[],"mappings":";;;AAAA;AAAA;AACA;AAAA;;;AAEO,MAAM,KAAK,CAAA,GAAA,uIAAA,CAAA,SAAM,AAAD,EAAE;IACvB,SAAS;QAAC,CAAA,GAAA,2KAAA,CAAA,WAAQ,AAAD;KAAI;IACrB,OAAO;AACT","debugId":null}},
    {"offset": {"line": 244, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/analyze-proctoring-logs.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview This file defines a Genkit flow for analyzing proctoring logs and flagging suspicious activities.\n *\n * - analyzeProctoringLogs - A function that takes proctoring logs as input and returns an analysis of suspicious activities.\n * - AnalyzeProctoringLogsInput - The input type for the analyzeProctoringLogs function.\n * - AnalyzeProctoringLogsOutput - The return type for the analyzeProctoringLogs function.\n */\n\nimport {ai} from '@/ai/genkit';\nimport {z} from 'genkit';\n\nconst ProctoringLogSchema = z.object({\n  id: z.string().describe('The ID of the log entry.'),\n  candidateId: z.string().describe('The ID of the candidate.'),\n  testId: z.string().describe('The ID of the test.'),\n  timestamp: z.string().describe('The timestamp of the event (ISO format).'),\n  status: z\n    .enum(['present', 'no_face', 'multiple_faces', 'tab_switch'])\n    .describe('The status of the candidate during proctoring.'),\n});\n\nexport type ProctoringLog = z.infer<typeof ProctoringLogSchema>;\n\nconst AnalyzeProctoringLogsInputSchema = z.object({\n  logs: z.array(ProctoringLogSchema).describe('An array of proctoring log entries.'),\n});\nexport type AnalyzeProctoringLogsInput = z.infer<typeof AnalyzeProctoringLogsInputSchema>;\n\nconst SuspiciousActivitySchema = z.object({\n  candidateId: z.string().describe('The ID of the candidate involved.'),\n  testId: z.string().describe('The ID of the test involved.'),\n  reason: z.string().describe('The reason for flagging the activity as suspicious.'),\n  timestamps: z.array(z.string()).describe('Timestamps of the suspicious events.'),\n});\n\nconst AnalyzeProctoringLogsOutputSchema = z.object({\n  summary: z.string().describe('A summary of the analysis of the proctoring logs.'),\n  suspiciousActivities: z\n    .array(SuspiciousActivitySchema)\n    .describe('An array of suspicious activities identified in the logs.'),\n});\nexport type AnalyzeProctoringLogsOutput = z.infer<typeof AnalyzeProctoringLogsOutputSchema>;\n\nexport async function analyzeProctoringLogs(input: AnalyzeProctoringLogsInput): Promise<AnalyzeProctoringLogsOutput> {\n  return analyzeProctoringLogsFlow(input);\n}\n\nconst analyzeProctoringLogsPrompt = ai.definePrompt({\n  name: 'analyzeProctoringLogsPrompt',\n  input: {schema: AnalyzeProctoringLogsInputSchema},\n  output: {schema: AnalyzeProctoringLogsOutputSchema},\n  prompt: `You are an AI assistant that analyzes proctoring logs from online tests to identify potential cheating incidents.\n\n  You are provided with an array of proctoring logs, each containing the candidate ID, test ID, timestamp, and status (present, no_face, multiple_faces, tab_switch).\n\n  Your task is to analyze these logs and identify any suspicious activities, such as:\n\n  1.  A candidate frequently disappearing from the camera (no_face status).\n  2.  The presence of multiple faces in the camera (multiple_faces status), which could indicate assistance from others.\n  3.  The candidate switching to another browser tab or application (tab_switch status).\n\n  For each suspicious activity, provide the candidate ID, test ID, a clear reason for flagging the activity as suspicious, and the timestamps of the events.\n\n  Also, provide a concise summary of your analysis.\n\n  Here are the proctoring logs:\n  {{#each logs}}\n  - Candidate ID: {{{candidateId}}}, Test ID: {{{testId}}}, Timestamp: {{{timestamp}}}, Status: {{{status}}}\n  {{/each}}\n\n  Ensure that the output is structured according to the AnalyzeProctoringLogsOutputSchema, including a summary and an array of suspicious activities with reasons and timestamps.\n  `,\n});\n\nconst analyzeProctoringLogsFlow = ai.defineFlow(\n  {\n    name: 'analyzeProctoringLogsFlow',\n    inputSchema: AnalyzeProctoringLogsInputSchema,\n    outputSchema: AnalyzeProctoringLogsOutputSchema,\n  },\n  async input => {\n    const {output} = await analyzeProctoringLogsPrompt(input);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AACA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,sBAAsB,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACnC,IAAI,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACxB,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACjC,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC5B,WAAW,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC/B,QAAQ,uIAAA,CAAA,IAAC,CACN,IAAI,CAAC;QAAC;QAAW;QAAW;QAAkB;KAAa,EAC3D,QAAQ,CAAC;AACd;AAIA,MAAM,mCAAmC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAChD,MAAM,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,qBAAqB,QAAQ,CAAC;AAC9C;AAGA,MAAM,2BAA2B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACxC,aAAa,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IACjC,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC5B,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC5B,YAAY,uIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,uIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,QAAQ,CAAC;AAC3C;AAEA,MAAM,oCAAoC,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACjD,SAAS,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC7B,sBAAsB,uIAAA,CAAA,IAAC,CACpB,KAAK,CAAC,0BACN,QAAQ,CAAC;AACd;AAGO,eAAe,sBAAsB,KAAiC;IAC3E,OAAO,0BAA0B;AACnC;AAEA,MAAM,8BAA8B,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAClD,MAAM;IACN,OAAO;QAAC,QAAQ;IAAgC;IAChD,QAAQ;QAAC,QAAQ;IAAiC;IAClD,QAAQ,CAAC;;;;;;;;;;;;;;;;;;;;EAoBT,CAAC;AACH;AAEA,MAAM,4BAA4B,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC7C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAM;IACJ,MAAM,EAAC,MAAM,EAAC,GAAG,MAAM,4BAA4B;IACnD,OAAO;AACT;;;IAxCoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 340, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/evaluate-answer.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview This file defines a Genkit flow for providing AI-powered suggestions for evaluating a candidate's answer.\n *\n * - evaluateAnswer - A function that takes a question, answer, and marks, and returns AI-generated feedback and a suggested score.\n * - EvaluateAnswerInput - The input type for the evaluateAnswer function.\n * - EvaluateAnswerOutput - The return type for the evaluateAnswer function.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\n\nconst EvaluateAnswerInputSchema = z.object({\n    questionText: z.string().describe('The text of the question.'),\n    questionType: z.enum(['mcq', 'puzzle', 'paragraph', 'image-mcq', 'video-mcq']).describe('The type of the question.'),\n    answer: z.string().describe(\"The candidate's answer.\"),\n    marks: z.number().describe('The total marks for the question.'),\n});\n\nexport type EvaluateAnswerInput = z.infer<typeof EvaluateAnswerInputSchema>;\n\nconst EvaluateAnswerOutputSchema = z.object({\n    feedback: z.string().describe(\"Detailed feedback on the candidate's answer, highlighting correctness, code quality, time complexity (for puzzle), and adherence to rubrics.\"),\n    suggestedScore: z.number().describe('A suggested score out of the total marks.'),\n});\n\nexport type EvaluateAnswerOutput = z.infer<typeof EvaluateAnswerOutputSchema>;\n\n\nexport async function evaluateAnswer(input: EvaluateAnswerInput): Promise<EvaluateAnswerOutput> {\n    return evaluateAnswerFlow(input);\n}\n\nconst evaluateAnswerPrompt = ai.definePrompt({\n    name: 'evaluateAnswerPrompt',\n    input: { schema: EvaluateAnswerInputSchema },\n    output: { schema: EvaluateAnswerOutputSchema },\n    prompt: `You are an expert evaluator for technical and skill-based assessments. Your task is to provide a detailed evaluation of a candidate's answer to a given question.\n\n    Question ({{questionType}}, {{marks}} marks):\n    {{questionText}}\n\n    Candidate's Answer:\n    {{answer}}\n\n    Based on the question and the candidate's answer, please provide:\n    1. Detailed feedback:\n        - For 'puzzle' questions: Analyze the correctness, time complexity, space complexity, and overall code quality (e.g., readability, best practices).\n        - For 'paragraph' (descriptive) questions: Evaluate the answer based on correctness, clarity, and depth of explanation against standard criteria for the topic.\n    2. A suggested score out of the total marks available for the question. The score should reflect the quality and correctness of the answer. Ensure the suggested score does not exceed the total marks.\n\n    Be objective and constructive in your feedback.\n    `,\n});\n\n\nconst evaluateAnswerFlow = ai.defineFlow(\n    {\n        name: 'evaluateAnswerFlow',\n        inputSchema: EvaluateAnswerInputSchema,\n        outputSchema: EvaluateAnswerOutputSchema,\n    },\n    async (input) => {\n        const { output } = await evaluateAnswerPrompt(input);\n        \n        if (output && output.suggestedScore > input.marks) {\n            output.suggestedScore = input.marks;\n        }\n\n        return output!;\n    }\n);\n\n    "],"names":[],"mappings":";;;;;AAEA;;;;;;CAMC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,4BAA4B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACvC,cAAc,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAClC,cAAc,uIAAA,CAAA,IAAC,CAAC,IAAI,CAAC;QAAC;QAAO;QAAU;QAAa;QAAa;KAAY,EAAE,QAAQ,CAAC;IACxF,QAAQ,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC5B,OAAO,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC/B;AAIA,MAAM,6BAA6B,uIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACxC,UAAU,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC9B,gBAAgB,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AACxC;AAKO,eAAe,eAAe,KAA0B;IAC3D,OAAO,mBAAmB;AAC9B;AAEA,MAAM,uBAAuB,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IACzC,MAAM;IACN,OAAO;QAAE,QAAQ;IAA0B;IAC3C,QAAQ;QAAE,QAAQ;IAA2B;IAC7C,QAAQ,CAAC;;;;;;;;;;;;;;;IAeT,CAAC;AACL;AAGA,MAAM,qBAAqB,mHAAA,CAAA,KAAE,CAAC,UAAU,CACpC;IACI,MAAM;IACN,aAAa;IACb,cAAc;AAClB,GACA,OAAO;IACH,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,qBAAqB;IAE9C,IAAI,UAAU,OAAO,cAAc,GAAG,MAAM,KAAK,EAAE;QAC/C,OAAO,cAAc,GAAG,MAAM,KAAK;IACvC;IAEA,OAAO;AACX;;;IAzCkB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 425, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/generate-company-motto.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview This file defines a Genkit flow for generating a company motto.\n *\n * - generateCompanyMotto - A function that takes a company name and returns a generated motto.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'genkit';\n\nconst GenerateCompanyMottoInputSchema = z.string().describe('The name of the company.');\nexport type GenerateCompanyMottoInput = z.infer<typeof GenerateCompanyMottoInputSchema>;\n\nconst GenerateCompanyMottoOutputSchema = z.string().describe('A short, catchy motto for the company.');\n\nexport async function generateCompanyMotto(companyName: GenerateCompanyMottoInput): Promise<string> {\n    return generateCompanyMottoFlow(companyName);\n}\n\nconst mottoPrompt = ai.definePrompt({\n  name: 'generateCompanyMottoPrompt',\n  input: { schema: GenerateCompanyMottoInputSchema },\n  output: { schema: GenerateCompanyMottoOutputSchema },\n  prompt: `You are a branding expert. Generate a short, catchy, and inspiring motto for the following tech company: {{{text}}}`,\n});\n\nconst generateCompanyMottoFlow = ai.defineFlow(\n  {\n    name: 'generateCompanyMottoFlow',\n    inputSchema: GenerateCompanyMottoInputSchema,\n    outputSchema: GenerateCompanyMottoOutputSchema,\n  },\n  async (companyName) => {\n    const { output } = await mottoPrompt(companyName);\n    return output!;\n  }\n);\n"],"names":[],"mappings":";;;;;AACA;;;;CAIC,GAED;AACA;AAAA;;;;;;AAEA,MAAM,kCAAkC,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAG5D,MAAM,mCAAmC,uIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAEtD,eAAe,qBAAqB,WAAsC;IAC7E,OAAO,yBAAyB;AACpC;AAEA,MAAM,cAAc,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IAClC,MAAM;IACN,OAAO;QAAE,QAAQ;IAAgC;IACjD,QAAQ;QAAE,QAAQ;IAAiC;IACnD,QAAQ,CAAC,mHAAmH,CAAC;AAC/H;AAEA,MAAM,2BAA2B,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC5C;IACE,MAAM;IACN,aAAa;IACb,cAAc;AAChB,GACA,OAAO;IACL,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,YAAY;IACrC,OAAO;AACT;;;IApBoB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 476, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/parse-mcq-flow.ts"],"sourcesContent":["'use server';\n/**\n * @fileOverview This file defines a Genkit flow for parsing a raw text of multiple-choice questions\n * into a structured format.\n *\n * - parseMcqQuestions - A function that takes a raw string of questions and returns a structured array.\n * - McqParserInput - The input type for the parseMcqQuestions function.\n * - McqParserOutput - The return type for the parseMcqQuestions function.\n */\n\nimport { ai } from '@/ai/genkit';\nimport { z } from 'zod';\n\nconst McqParserInputSchema = z.string().describe('A raw string containing multiple-choice questions and their options.');\n\nexport type McqParserInput = z.infer<typeof McqParserInputSchema>;\n\nconst ParsedQuestionSchema = z.object({\n    questionText: z.string().describe('The main text of the question.'),\n    options: z.array(z.string()).describe('An array of possible answers.'),\n    answer: z.string().describe('The correct answer from the options.'),\n    marks: z.number().describe('The marks for the question, default to 10.'),\n});\n\nconst McqParserOutputSchema = z.object({\n    questions: z.array(ParsedQuestionSchema).describe('An array of parsed question objects.')\n});\n\nexport type McqParserOutput = z.infer<typeof McqParserOutputSchema>;\n\nexport async function parseMcqQuestions(input: McqParserInput): Promise<McqParserOutput> {\n    return parseMcqFlow(input);\n}\n\nconst parseMcqPrompt = ai.definePrompt({\n    name: 'parseMcqPrompt',\n    input: { schema: McqParserInputSchema },\n    output: { schema: McqParserOutputSchema },\n    prompt: `You are an expert data parser specializing in Multiple-Choice Questions (MCQs). You will be given a raw string that may contain a mix of text, but your job is to find and structure only the MCQs.\n\nYour task is to parse the string and convert it into a structured JSON object containing an array of questions. For each question you find, you MUST identify:\n1.  The question text. Questions are usually numbered (e.g., \"Q1.\", \"1)\", \"Question 1:\") or start a new paragraph.\n2.  The list of options. Options are typically lettered (a, b, c) or numbered (1, 2, 3) and may or may not have parentheses or dots.\n3.  The correct answer. First, look for an explicit answer key (e.g., \"Answer: C\", \"Correct answer is B\"). If no explicit key is found for a question, you MUST use your own knowledge to determine the correct answer from the provided options. The answer you provide must exactly match one of the options you extracted.\n4.  Assign a default of 10 marks to each question.\n\nIgnore any text that does not appear to be part of an MCQ.\n\nHere is the text you need to parse:\n{{{text}}}\n\nPlease provide the output in the specified JSON format.\n`,\n});\n\nconst parseMcqFlow = ai.defineFlow(\n    {\n        name: 'parseMcqFlow',\n        inputSchema: McqParserInputSchema,\n        outputSchema: McqParserOutputSchema,\n    },\n    async (text) => {\n        const { output } = await parseMcqPrompt(text);\n        return output!;\n    }\n);\n"],"names":[],"mappings":";;;;;AACA;;;;;;;CAOC,GAED;AACA;;;;;;AAEA,MAAM,uBAAuB,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAIjD,MAAM,uBAAuB,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IAClC,cAAc,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAClC,SAAS,oIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,oIAAA,CAAA,IAAC,CAAC,MAAM,IAAI,QAAQ,CAAC;IACtC,QAAQ,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;IAC5B,OAAO,oIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,QAAQ,CAAC;AAC/B;AAEA,MAAM,wBAAwB,oIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACnC,WAAW,oIAAA,CAAA,IAAC,CAAC,KAAK,CAAC,sBAAsB,QAAQ,CAAC;AACtD;AAIO,eAAe,kBAAkB,KAAqB;IACzD,OAAO,aAAa;AACxB;AAEA,MAAM,iBAAiB,mHAAA,CAAA,KAAE,CAAC,YAAY,CAAC;IACnC,MAAM;IACN,OAAO;QAAE,QAAQ;IAAqB;IACtC,QAAQ;QAAE,QAAQ;IAAsB;IACxC,QAAQ,CAAC;;;;;;;;;;;;;;AAcb,CAAC;AACD;AAEA,MAAM,eAAe,mHAAA,CAAA,KAAE,CAAC,UAAU,CAC9B;IACI,MAAM;IACN,aAAa;IACb,cAAc;AAClB,GACA,OAAO;IACH,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,eAAe;IACxC,OAAO;AACX;;;IAlCkB;;AAAA,+OAAA","debugId":null}},
    {"offset": {"line": 551, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/lib/actions.ts"],"sourcesContent":["'use server';\n\nimport { analyzeProctoringLogs, type ProctoringLog } from '@/ai/flows/analyze-proctoring-logs';\nimport { evaluateAnswer, type EvaluateAnswerInput } from '@/ai/flows/evaluate-answer';\nimport { generateCompanyMotto } from '@/ai/flows/generate-company-motto';\nimport { parseMcqQuestions, type McqParserInput } from '@/ai/flows/parse-mcq-flow';\nimport { z } from 'zod';\n\nconst proctoringLogSchema = z.object({\n  id: z.string(),\n  candidateId: z.string(),\n  testId: z.string(),\n  timestamp: z.string(),\n  status: z.enum(['present', 'no_face', 'multiple_faces', 'tab_switch']),\n});\n\nconst proctoringLogsSchema = z.array(proctoringLogSchema);\n\n\nexport async function getAnalysis(logs: Omit<ProctoringLog, 'id'>[]) {\n  // Validate input with Zod. This is a good practice for server actions.\n  const logsWithIds = logs.map((log, index) => ({ ...log, id: `log-${index}` }));\n  const validatedLogs = proctoringLogsSchema.safeParse(logsWithIds);\n\n  if (!validatedLogs.success) {\n    return { error: 'Invalid log format.' };\n  }\n\n  try {\n    const analysis = await analyzeProctoringLogs({ logs: validatedLogs.data });\n    return { data: analysis };\n  } catch (error) {\n    console.error('Error analyzing logs:', error);\n    return { error: 'Failed to analyze logs.' };\n  }\n}\n\nconst evaluateAnswerInputSchema = z.object({\n    questionText: z.string(),\n    questionType: z.enum(['mcq', 'coding', 'paragraph', 'image', 'audio']),\n    answer: z.string(),\n    marks: z.number(),\n});\n\nexport async function getAIEvaluation(input: EvaluateAnswerInput) {\n    const validatedInput = evaluateAnswerInputSchema.safeParse(input);\n\n    if (!validatedInput.success) {\n        return { error: 'Invalid input format.' };\n    }\n    \n    try {\n        const evaluation = await evaluateAnswer(validatedInput.data);\n        return { data: evaluation };\n    } catch (error) {\n        console.error('Error getting AI evaluation:', error);\n        return { error: 'Failed to get AI evaluation.' };\n    }\n}\n\nconst companyMottoInputSchema = z.string();\n\nexport async function getCompanyMotto(companyName: string) {\n    const validatedInput = companyMottoInputSchema.safeParse(companyName);\n\n    if (!validatedInput.success) {\n        return { error: 'Invalid input format.' };\n    }\n\n    try {\n        const motto = await generateCompanyMotto(validatedInput.data);\n        return { data: motto };\n    } catch(error) {\n        console.error('Error generating company motto:', error);\n        return { error: 'Failed to generate company motto.' };\n    }\n}\n\nconst bulkQuestionsInputSchema = z.string();\n\nexport async function processBulkQuestions(input: string) {\n  const validatedInput = bulkQuestionsInputSchema.safeParse(input);\n\n  if (!validatedInput.success) {\n    return { error: 'Invalid input format. Expected a raw string.'};\n  }\n\n  try {\n    const result = await parseMcqQuestions(validatedInput.data as McqParserInput);\n    return { data: result };\n  } catch(error) {\n    console.error('Error processing bulk questions:', error);\n    return { error: 'Failed to process questions using AI.'};\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 699, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/.next-internal/server/app/%28evaluator%29/evaluator/submission/%5BsubmissionId%5D/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["export {getAIEvaluation as '401d28a9e45bd60e1383093ec21d0e6ca1a1ab15bd'} from 'ACTIONS_MODULE0'\n"],"names":[],"mappings":";AAAA","debugId":null}},
    {"offset": {"line": 757, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/%28evaluator%29/evaluator/submission/%5BsubmissionId%5D/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/(evaluator)/evaluator/submission/[submissionId]/page.tsx <module evaluation> from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/(evaluator)/evaluator/submission/[submissionId]/page.tsx <module evaluation>\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAoU,GACjW,kGACA","debugId":null}},
    {"offset": {"line": 771, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/%28evaluator%29/evaluator/submission/%5BsubmissionId%5D/page.tsx/proxy.mjs"],"sourcesContent":["import { registerClientReference } from \"react-server-dom-turbopack/server.edge\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/(evaluator)/evaluator/submission/[submissionId]/page.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/(evaluator)/evaluator/submission/[submissionId]/page.tsx\",\n    \"default\",\n);\n"],"names":[],"mappings":";;;AAAA;;uCACe,CAAA,GAAA,qPAAA,CAAA,0BAAuB,AAAD,EACjC;IAAa,MAAM,IAAI,MAAM;AAAgT,GAC7U,8EACA","debugId":null}},
    {"offset": {"line": 785, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}}]
}